{"entries":[{"timestamp":1756080120954,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":31,"diffs":[[1,"    \"name\": \"tilemaps\",\n"]]},{"start1":178,"length1":66,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":207,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"tilemaps.ts","value":"enum TileScale2 {\n    //% block=\"4x4\"\n    Four = 2,\n    //% block=\"8x8\"\n    Eight = 3,\n    //% block=\"16x16\"\n    Sixteen = 4,\n    //% block=\"32x32\"\n    ThirtyTwo = 5\n}\n\n\n\nnamespace tiles2 {\n\n    /**\n     * A (col, row) location in the tilemap\n     **/\n    //% blockNamespace=tilesUpdate color=\"#401255\"\n    export class Location {\n        protected _row: number;\n        protected _col: number;\n\n        constructor(col: number, row: number, map: TileMap) {\n            this._col = col;\n            this._row = row;\n        }\n\n        get tileMap() {\n            return scene.tileMap;\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"column\"\n        //% weight=100\n        get column() {\n            return this._col;\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"row\"\n        //% weight=100\n        get row() {\n            return this._row;\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"x\"\n        //% weight=100\n        get x(): number {\n            const scale = this.tileMap.scale;\n            return (this._col << scale) + (1 << (scale - 1));\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"y\"\n        //% weight=100\n        get y(): number {\n            const scale = this.tileMap.scale;\n            return (this._row << scale) + (1 << (scale - 1));\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"left\"\n        //% weight=100\n        get left(): number {\n            return (this._col << this.tileMap.scale);\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"top\"\n        //% weight=100\n        get top(): number {\n            return (this._row << this.tileMap.scale);\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"right\"\n        //% weight=100\n        get right(): number {\n            return this.left + (1 << this.tileMap.scale);\n        }\n\n        //% group=\"Locations\" blockSetVariable=\"location\"\n        //% blockCombine block=\"bottom\"\n        //% weight=100\n        get bottom(): number {\n            return this.top + (1 << this.tileMap.scale);\n        }\n\n        get tileSet(): number {\n            return this.tileMap.getTileIndex(this._col, this._row);\n        }\n\n        // deprecated\n        get col() {\n            return this.column;\n        }\n\n        public isWall(): boolean {\n            return this.tileMap.isObstacle(this._col, this._row);\n        }\n\n        public getImage(): Image {\n            return this.tileMap.getTileImage(this.tileSet);\n        }\n\n        /**\n         * Returns the neighboring location in a specifc direction from a location in a tilemap\n         * @param direction The direction to fetch the location in\n         */\n        //% blockId=tiles_location_get_neighboring_location2\n        //% block=\"tilemap location $direction of $this\"\n        //% this.defl=location\n        //% this.shadow=variables_get\n        //% group=\"Locations\" blockGap=8\n        //% weight=10 help=tiles/get-neighboring-location\n        public getNeighboringLocation(direction: CollisionDirection): Location {\n            switch (direction) {\n                case CollisionDirection.Top:\n                    return this.tileMap.getTile(this._col, this._row - 1);\n                case CollisionDirection.Right:\n                    return this.tileMap.getTile(this._col + 1, this._row);\n                case CollisionDirection.Bottom:\n                    return this.tileMap.getTile(this._col, this._row + 1);\n                case CollisionDirection.Left:\n                    return this.tileMap.getTile(this._col - 1, this._row);\n            }\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n            mySprite.setPosition(this.x, this.y);\n        }\n\n        // ## LEGACY: DO NOT USE ##\n        _toTile(): Tile {\n            return new Tile(this._col, this._row, this.tileMap);\n        }\n    }\n\n    /**\n     * DEPRECATED: a tile in the tilemap\n     **/\n    //% blockNamespace=tilesUpdate color=\"#401255\" blockGap=8\n    export class Tile {\n        protected _row: number;\n        protected _col: number;\n        protected tileMap: TileMap;\n\n        constructor(col: number, row: number, map: TileMap) {\n            this._col = col;\n            this._row = row;\n            this.tileMap = map;\n        }\n\n        get x(): number {\n            const scale = this.tileMap.scale;\n            return (this._col << scale) + (1 << (scale - 1));\n        }\n\n        get y(): number {\n            const scale = this.tileMap.scale;\n            return (this._row << scale) + (1 << (scale - 1));\n        }\n\n        get tileSet(): number {\n            return this.tileMap.getTileIndex(this._col, this._row);\n        }\n\n        /**\n         * Center the given sprite on this tile\n         * @param sprite\n         */\n        //% blockId=gameplaceontile2 block=\"on top of %tile(myTile) place %sprite=variables_get(mySprite)\"\n        //% blockNamespace=\"scene\" group=\"Tilemap Operations\"\n        //% weight=25\n        //% help=tiles/place\n        //% deprecated=1\n        place(mySprite: Sprite): void {\n            if (!mySprite) return;\n            mySprite.setPosition(this.x, this.y);\n        }\n    }\n\n    const TM_DATA_PREFIX_LENGTH = 4;\n    const TM_WALL = 2;\n\n    //% snippet='tilemap` `'\n    //% pySnippet='tilemap(\"\"\" \"\"\")'\n    export class TileMapData {\n        // The tile data for the map (indices into tileset)\n        protected data: Buffer;\n\n        // The metadata layers for the map. Currently only 1 is used for walls\n        protected layers: Image;\n\n        protected tileset: Image[];\n        protected cachedTileView: Image[];\n\n        protected _scale: TileScale2;\n        protected _width: number;\n        protected _height: number;\n\n        constructor(data: Buffer, layers: Image, tileset: Image[], scale: TileScale2) {\n            this.data = data;\n            this.layers = layers;\n            this.tileset = tileset;\n            this.scale = scale;\n\n            this._width = data.getNumber(NumberFormat.UInt16LE, 0);\n            this._height = data.getNumber(NumberFormat.UInt16LE, 2);\n        }\n\n        get width(): number {\n            return this._width;\n        }\n\n        get height(): number {\n            return this._height;\n        }\n\n        get scale(): TileScale2 {\n            return this._scale;\n        }\n\n        set scale(s: TileScale2) {\n            this._scale = s;\n            this.cachedTileView = [];\n        }\n\n        getTile(col: number, row: number) {\n            if (this.isOutsideMap(col, row)) return 0;\n\n            return this.data.getUint8(TM_DATA_PREFIX_LENGTH + (col | 0) + (row | 0) * this.width);\n        }\n\n        setTile(col: number, row: number, tile: number) {\n            if (this.isOutsideMap(col, row)) return;\n\n            if (this.data.isReadOnly()) {\n                this.data = this.data.slice();\n            }\n\n            this.data.setUint8(TM_DATA_PREFIX_LENGTH + (col | 0) + (row | 0) * this.width, tile);\n        }\n\n        getTileset() {\n            return this.tileset;\n        }\n\n        getTileImage(index: number) {\n            const size = 1 << this.scale;\n            let cachedImage = this.cachedTileView[index];\n            if (!cachedImage) {\n                const originalImage = this.tileset[index];\n\n                if (originalImage) {\n                    if (originalImage.width <= size && originalImage.height <= size) {\n                        cachedImage = originalImage;\n                    } else {\n                        cachedImage = image.create(size, size);\n                        cachedImage.drawImage(originalImage, 0, 0);\n                    }\n                    this.cachedTileView[index] = cachedImage;\n                }\n            }\n            return cachedImage;\n        }\n\n        setWall(col: number, row: number, on: boolean) {\n            return this.layers.setPixel(col, row, on ? TM_WALL : 0);\n        }\n\n        isWall(col: number, row: number) {\n            return this.layers.getPixel(col, row) === TM_WALL;\n        }\n\n        isOutsideMap(col: number, row: number) {\n            return col < 0 || col >= this.width || row < 0 || row >= this.height;\n        }\n    }\n\n    export enum TileMapEvent {\n        Loaded,\n        Unloaded\n    }\n\n    export class TileMapEventHandler {\n        constructor(public event: TileMapEvent, public callback: (data: TileMapData) => void) { }\n    }\n\n    export class TileMap {\n        protected _scale: TileScale2;\n\n        protected _layer: number;\n        protected _map: TileMapData;\n        renderable: scene.Renderable;\n        protected handlerState: TileMapEventHandler[];\n\n        constructor(scale: TileScale2 = TileScale2.Sixteen) {\n            this._layer = 1;\n            this.scale = scale;\n\n            this.renderable = scene.createRenderable(\n                scene.TILE_MAP_Z,\n                (t, c) => this.draw(t, c)\n            );\n        }\n\n        get scale() {\n            return this._scale;\n        }\n\n        set scale(s: TileScale2) {\n            this._scale = s;\n            if (this._map) {\n                this._map.scale = s;\n            }\n        }\n\n        get data(): TileMapData {\n            return this._map;\n        }\n\n        offsetX(value: number) {\n            return Math.clamp(0, Math.max(this.areaWidth() - screen.width, 0), value);\n        }\n\n        offsetY(value: number) {\n            return Math.clamp(0, Math.max(this.areaHeight() - screen.height, 0), value);\n        }\n\n        areaWidth() {\n            return this._map ? (this._map.width << this.scale) : 0;\n        }\n\n        areaHeight() {\n            return this._map ? (this._map.height << this.scale) : 0;\n        }\n\n        get layer(): number {\n            return this._layer;\n        }\n\n        set layer(value: number) {\n            if (this._layer != value) {\n                this._layer = value;\n            }\n        }\n\n        get enabled(): boolean {\n            return !!this._map;\n        }\n\n        setData(map: TileMapData) {\n            const previous = this._map;\n\n            if (this.handlerState && previous !== map && previous) {\n                for (const eventHandler of this.handlerState) {\n                    if (eventHandler.event === TileMapEvent.Unloaded) {\n                        eventHandler.callback(previous);\n                    }\n                }\n            }\n\n            this._map = map;\n            if (map) {\n                this._scale = map.scale;\n            }\n\n            if (this.handlerState && previous !== map && map) {\n                for (const eventHandler of this.handlerState) {\n                    if (eventHandler.event === TileMapEvent.Loaded) {\n                        eventHandler.callback(map);\n                    }\n                }\n            }\n        }\n\n        public getTile(col: number, row: number): Location {\n            return new Location(col, row, this);\n        }\n\n        public getTileIndex(col: number, row: number) {\n            return this.data.getTile(col, row);\n        }\n\n        public setTileAt(col: number, row: number, index: number): void {\n            if (!this._map.isOutsideMap(col, row) && !this.isInvalidIndex(index))\n                this._map.setTile(col, row, index);\n        }\n\n        public getImageType(im: Image): number {\n            const tileset = this._map.getTileset();\n            for (let i = 0; i < tileset.length; i++)\n                if (tileset[i].equals(im)) return i;\n\n            // not found; append to the tileset if there are spots left.\n            const newIndex = tileset.length;\n            if (!this.isInvalidIndex(newIndex)) {\n                tileset.push(im);\n                return newIndex;\n            }\n\n            return -1;\n        }\n\n        public setWallAt(col: number, row: number, on: boolean): void {\n            if (!this._map.isOutsideMap(col, row))\n                this._map.setWall(col, row, on);\n        }\n\n        public getTilesByType(index: number): Location[] {\n            if (this.isInvalidIndex(index) || !this.enabled) return [];\n\n            let output: Location[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getTile(col, row);\n                    if (currTile === index) {\n                        output.push(new Location(col, row, this));\n                    }\n                }\n            }\n            return output;\n        }\n\n        public sampleTilesByType(index: number, maxCount: number): Location[] {\n            if (this.isInvalidIndex(index) || !this.enabled || maxCount <= 0) return [];\n\n            let count = 0;\n            const reservoir: Location[] = [];\n            for (let col = 0; col < this._map.width; ++col) {\n                for (let row = 0; row < this._map.height; ++row) {\n                    let currTile = this._map.getTile(col, row);\n                    if (currTile === index) {\n                        // first **maxCount** elements just enqueue\n                        if (count < maxCount) {\n                            reservoir.push(new Location(col, row, this));\n                        } else {\n                            const potentialIndex = randint(0, count);\n                            if (potentialIndex < maxCount) {\n                                reservoir[potentialIndex] = new Location(col, row, this);\n                            }\n                        }\n                        ++count;\n                    }\n                }\n            }\n\n            return reservoir;\n        }\n\n        protected isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xff;\n        }\n\n        protected draw(target: Image, camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            // render tile map\n            const bitmask = (0x1 << this.scale) - 1;\n            const offsetX = camera.drawOffsetX & bitmask;\n            const offsetY = camera.drawOffsetY & bitmask;\n\n            const x0 = Math.max(0, camera.drawOffsetX >> this.scale);\n            const xn = Math.min(this._map.width, ((camera.drawOffsetX + target.width) >> this.scale) + 1);\n            const y0 = Math.max(0, camera.drawOffsetY >> this.scale);\n            const yn = Math.min(this._map.height, ((camera.drawOffsetY + target.height) >> this.scale) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getTile(x, y);\n                    const tile = this._map.getTileImage(index);\n                    if (tile) {\n                        target.drawTransparentImage(\n                            tile,\n                            ((x - x0) << this.scale) - offsetX,\n                            ((y - y0) << this.scale) - offsetY\n                        );\n                    }\n                }\n            }\n\n            if (game.debug) {\n                // render debug grid overlay\n                for (let x = x0; x <= xn; ++x) {\n                    const xLine = ((x - x0) << this.scale) - offsetX;\n                    if (xLine >= 0 && xLine <= screen.width) {\n                        target.drawLine(\n                            xLine,\n                            0,\n                            xLine,\n                            target.height,\n                            1\n                        );\n                    }\n                }\n\n                for (let y = y0; y <= yn; ++y) {\n                    const yLine = ((y - y0) << this.scale) - offsetY;\n                    if (yLine >= 0 && yLine <= screen.height) {\n                        target.drawLine(\n                            0,\n                            yLine,\n                            target.width,\n                            yLine,\n                            1\n                        );\n                    }\n                }\n            }\n        }\n\n        public isObstacle(col: number, row: number) {\n            if (!this.enabled) return false;\n            if (this._map.isOutsideMap(col, row)) return true;\n\n            return this._map.isWall(col, row);\n        }\n\n        public getObstacle(col: number, row: number) {\n            const index = this._map.isOutsideMap(col, row) ? 0 : this._map.getTile(col, row);\n            const tile = this._map.getTileImage(index);\n            return new sprites.StaticObstacle(\n                tile,\n                row << this.scale,\n                col << this.scale,\n                this.layer,\n                index\n            );\n        }\n\n        public isOnWall(s: Sprite) {\n            const hbox = s._hitbox;\n\n            const left = Fx.toIntShifted(hbox.left, this.scale);\n            const right = Fx.toIntShifted(hbox.right, this.scale);\n            const top = Fx.toIntShifted(hbox.top, this.scale);\n            const bottom = Fx.toIntShifted(hbox.bottom, this.scale);\n\n            for (let col = left; col <= right; ++col) {\n                for (let row = top; row <= bottom; ++row) {\n                    if (this.isObstacle(col, row)) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        public getTileImage(index: number) {\n            return this.data.getTileImage(index);\n        }\n\n        public addEventListener(event: TileMapEvent, handler: (data: TileMapData) => void) {\n            if (!this.handlerState) this.handlerState = [];\n\n            for (const eventHandler of this.handlerState) {\n                if (eventHandler.event === event && eventHandler.callback === handler) return;\n            }\n            this.handlerState.push(new TileMapEventHandler(event, handler));\n        }\n\n        public removeEventListener(event: TileMapEvent, handler: (data: TileMapData) => void) {\n            if (!this.handlerState) return;\n\n            for (let i = 0; i < this.handlerState.length; i++) {\n                if (this.handlerState[i].event === event && this.handlerState[i].callback === handler) {\n                    this.handlerState.splice(i, 1)\n                    return;\n                }\n            }\n        }\n    }\n\n    function mkColorTile(index: number, scale: TileScale2): Image {\n        const size = 1 << scale\n\n        const i = image.create(size, size);\n        i.fill(index);\n        return i;\n    }\n\n    //% scale.defl=\"TileScale2.Sixteen\"\n    export function createTilemap(data: Buffer, layer: Image, tiles: Image[], scale: TileScale2): TileMapData {\n        return new TileMapData(data, layer, tiles, scale)\n    }\n\n    //% blockId=tilemap_editor2 block=\"set tilemap to $tilemap\"\n    //% weight=200 blockGap=8\n    //% tilemap.fieldEditor=\"tilemap\"\n    //% tilemap.fieldOptions.decompileArgumentAsString=\"true\"\n    //% tilemap.fieldOptions.filter=\"tile\"\n    //% tilemap.fieldOptions.taggedTemplate=\"tilemap\"\n    //% blockNamespace=\"scene\" duplicateShadowOnDrag\n    //% help=tiles/set-tilemap\n    //% deprecated=1\n    export function setTilemap(tilemap: TileMapData) {\n        setCurrentTilemap(tilemap);\n    }\n\n    /**\n     * Sets the given tilemap to be the current active tilemap in the game\n     *\n     * @param tilemap The tilemap to set as the current tilemap\n     */\n    //% blockId=set_current_tilemap2 block=\"set tilemap to $tilemap\"\n    //% weight=201 blockGap=8\n    //% tilemap.shadow=tiles_tilemap_editor\n    //% blockNamespace=\"scene\" group=\"Tilemaps\" duplicateShadowOnDrag\n    //% help=tiles/set-current-tilemap\n    export function setCurrentTilemap(tilemap: TileMapData) {\n        tilesUpdate.setTileMapLevel(tilemap);\n    }\n\n    /**\n     * Set a location in the map (column, row) to a tile\n     * @param loc\n     * @param tile\n     */\n    //% blockId=mapsettileat2 block=\"set $tile at $loc=mapgettile\"\n    //% tile.shadow=tileset_tile_picker\n    //% tile.decompileIndirectFixedInstances=true\n    //% blockNamespace=\"scene\" group=\"Tilemap Operations\" blockGap=8\n    //% help=tiles/set-tile-at\n    //% weight=70\n    export function setTileAt(loc: Location, tile: Image): void {\n        const scene = game.currentScene();\n        if (!loc || !tile || !scene.tileMap) return null;\n        const scale = scene.tileMap.scale;\n        const index = scene.tileMap.getImageType(tile);\n        scene.tileMap.setTileAt(loc.x >> scale, loc.y >> scale, index);\n    }\n\n    /**\n     * Set or unset a wall at a location in the map (column, row)\n     * @param loc\n     * @param on\n     */\n    //% blockId=mapsetwallat2 block=\"set wall $on at $loc\"\n    //% on.shadow=toggleOnOff loc.shadow=mapgettile\n    //% blockNamespace=\"scene\" group=\"Tilemap Operations\"\n    //% help=tiles/set-wall-at\n    //% weight=60\n    export function setWallAt(loc: Location, on: boolean): void {\n        const scene = game.currentScene();\n        if (!loc || !scene.tileMap) return null;\n        const scale = scene.tileMap.scale;\n        scene.tileMap.setWallAt(loc.x >> scale, loc.y >> scale, on);\n    }\n\n    /**\n     * Get the tile position given a column and row in the tilemap\n     * @param col\n     * @param row\n     */\n    //% blockId=mapgettile2 block=\"tilemap col $col row $row\"\n    //% blockNamespace=\"scene\" group=\"Locations\"\n    //% weight=100 blockGap=8\n    //% help=tiles/get-tile-location\n    export function getTileLocation(col: number, row: number): Location {\n        if (col == undefined || row == undefined || !scene.tileMap) return null;\n        return scene.tileMap.getTile(col, row);\n    }\n\n    /**\n     * Get the image of a tile, given a location in the tilemap\n     * @param loc\n     */\n    export function getTileImage(loc: Location): Image {\n        const scene = game.currentScene();\n        if (!loc || !scene.tileMap) return img``;\n        return scene.tileMap.getTileImage(loc.tileSet);\n    }\n\n    /**\n     * Get the image of a tile, given a (column, row) in the tilemap\n     * @param loc\n     */\n    export function getTileAt(col: number, row: number): Image {\n        const scene = game.currentScene();\n        if (col == undefined || row == undefined || !scene.tileMap) return img``;\n        return scene.tileMap.getTileImage(tiles.getTileLocation(col, row).tileSet);\n    }\n\n    /**\n     * Returns true if the tile at the given location is the same as the given tile;\n     * otherwise returns false\n     * @param location\n     * @param tile\n     */\n    //% blockId=maplocationistile2 block=\"tile at $location is $tile\"\n    //% location.shadow=mapgettile\n    //% tile.shadow=tileset_tile_picker tile.decompileIndirectFixedInstances=true\n    //% blockNamespace=\"scene\" group=\"Locations\" blockGap=8\n    //% weight=40 help=tiles/tile-at-location-equals\n    export function tileAtLocationEquals(location: Location, tile: Image): boolean {\n        const scene = game.currentScene();\n        if (!location || !tile || !scene.tileMap) return false;\n        return location.tileSet === scene.tileMap.getImageType(tile);\n    }\n\n    /**\n     * Returns true if the tile at the given location is a wall in the current tilemap;\n     * otherwise returns false\n     * @param location The location to check for a wall\n     */\n    //% blockId=tiles_tile_at_location_is_wall2\n    //% block=\"tile at $location is wall\"\n    //% location.shadow=mapgettile\n    //% blockNamespace=\"scene\" group=\"Locations\" blockGap=8\n    //% weight=30 help=tiles/tile-at-location-is-wall\n    export function tileAtLocationIsWall(location: Location): boolean {\n        if (!location || !location.tileMap) return false;\n        return location.isWall();\n    }\n\n    /**\n     * Returns the image of the tile at the given location in the current tilemap\n     *\n     * @param location The location of the image to fetch\n     */\n    //% blockId=tiles_image_at_location2\n    //% block=\"tile image at $location\"\n    //% location.shadow=mapgettile\n    //% weight=0 help=tiles/tile-image-at-location\n    //% blockNamespace=\"scene\" group=\"Locations\"\n    export function tileImageAtLocation(location: Location): Image {\n        const scene = game.currentScene();\n        if (!location || !scene.tileMap) return img``;\n        return location.getImage();\n    }\n\n    /**\n     * Center the given sprite on a given location\n     * @param sprite\n     * @param loc\n     */\n    //% blockId=mapplaceontile2 block=\"place $sprite=variables_get(mySprite) on top of $loc\"\n    //% loc.shadow=mapgettile\n    //% blockNamespace=\"scene\" group=\"Tilemap Operations\" blockGap=8\n    //% help=tiles/place-on-tile\n    //% weight=100\n    export function placeOnTile(sprite: Sprite, loc: Location): void {\n        if (!sprite || !loc || !loc.tileMap) return;\n        loc.place(sprite);\n    }\n\n    /**\n     * Center the given sprite on a random location that is the given type (image)\n     * @param sprite\n     * @param tile\n     */\n    //% blockId=mapplaceonrandomtile2 block=\"place $sprite=variables_get(mySprite) on top of random $tile\"\n    //% tile.shadow=tileset_tile_picker\n    //% tile.decompileIndirectFixedInstances=true\n    //% blockNamespace=\"scene\" group=\"Tilemap Operations\"\n    //% help=tiles/place-on-random-tile\n    //% weight=90\n    export function placeOnRandomTile(sprite: Sprite, tile: Image): void {\n        if (!sprite || !game.currentScene().tileMap) return;\n        const loc = getRandomTileByType(tile);\n        if (loc)\n            loc.place(sprite);\n    }\n\n    /**\n     * Get all tiles in the tilemap with the given type (image).\n     * @param tile\n     */\n    //% blockId=mapgettilestype2 block=\"array of all $tile locations\"\n    //% tile.shadow=tileset_tile_picker\n    //% tile.decompileIndirectFixedInstances=true\n    //% blockNamespace=\"scene\" group=\"Locations\" blockGap=8\n    //% help=tiles/get-tiles-by-type\n    //% weight=10\n    export function getTilesByType(tile: Image): Location[] {\n        if (!tile || !scene.tileMap) return [];\n        const index = scene.tileMap.getImageType(tile);\n        return scene.tileMap.getTilesByType(index);\n    }\n\n    /**\n     * Get a random tile of the given type\n     * @param tile the type of tile to get a random selection of\n     */\n    export function getRandomTileByType(tile: Image): Location {\n        if (!tile || !scene.tileMap)\n            return undefined;\n        const index = scene.tileMap.getImageType(tile);\n        const sample = scene.tileMap.sampleTilesByType(index, 1);\n        return sample[0];\n    }\n\n    /**\n     * A tilemap\n     */\n    //% blockId=tiles_tilemap_editor2 shim=TD_ID\n    //% weight=200 blockGap=8\n    //% block=\"tilemap $tilemap\"\n    //% tilemap.fieldEditor=\"tilemap\"\n    //% tilemap.fieldOptions.decompileArgumentAsString=\"true\"\n    //% tilemap.fieldOptions.filter=\"tile\"\n    //% tilemap.fieldOptions.taggedTemplate=\"tilemap\"\n    //% blockNamespace=\"scene\" group=\"Tilemaps\" duplicateShadowOnDrag\n    //% help=tiles/tilemap\n    export function _tilemapEditor(tilemap: TileMapData): TileMapData {\n        return tilemap;\n    }\n\n    /**\n     * Adds an event handler that will fire whenever the specified event\n     * is triggered. Unloaded tilemap events will fire before the new tilemap\n     * is set and loaded events will fire afterwards. The same handler can\n     * not be added for the same event more than once.\n     *\n     * @param event     The event to subscribe to\n     * @param handler   The code to run when the event triggers\n     */\n    export function addEventListener(event: TileMapEvent, callback: (data: TileMapData) => void) {\n\n        if (!scene.tileMap) {\n            scene.tileMap = new TileMap();\n        }\n\n        scene.tileMap.addEventListener(event, callback);\n    }\n\n\n    /**\n     * Removes an event handler registered with addEventListener.\n     *\n     * @param event     The event that the handler was registered for\n     * @param handler   The handler to remove\n     */\n    export function removeEventListener(event: TileMapEvent, callback: (data: TileMapData) => void) {\n\n        if (!scene.tileMap) return;\n\n        scene.tileMap.removeEventListener(event, callback);\n    }\n}\n"},{"type":"added","filename":"scenes.ts","value":"namespace scene {\n  export let tileMap = new tiles2.TileMap(TileScale2.Eight)\n}\nnamespace tilesUpdate {\n    export function setTileMapLevel(map: tiles2.TileMapData) {\n        if (!scene.tileMap)\n            scene.tileMap = new tiles2.TileMap();\n        scene.tileMap.setData(map);\n    }\n}"}]},{"timestamp":1756080702641,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":258,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1756080120953,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"tilemaps\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1756080738107}